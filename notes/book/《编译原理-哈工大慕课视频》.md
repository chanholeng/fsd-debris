# 编译原理

## 第一讲 绪论

### 什么是编译

* 计算机程序设计语言：

  * 高级语言：```x = 2```
  * 汇编语言：```MOV X, 2```
  * 机器语言：```C706 0000 0002```

* 编译：将高级语言翻译成汇编语言或机器语言

* 编译器在语言处理系统中的位置：

  * 源程序。

  * 预处理器：把存储在不同文件中的源程序聚合在一起；把被称为宏的缩写语句转换为原始语句。

  * 经过预处理器处理的源程序

  * 编译器。

  * 汇编语言程序。

  * 汇编器。

  * 可重定位的机器代码：可重定位，在内存中存放的起始位置 L 不是固定的。

    * ```起始位置 + 相对地址 = 绝对地址```

  * 链接器/加载器：

    * 链接器：大型程序经常被分割成多个部分进行编译，通常需要用链接器将其它可重定位的目标程序以及库文件进行链接，解决外部内存地址问题（一个文件代码要引入另一个文件数据对象时的相对外部地址）。


    * 加载器：修改可重定位地址，将修改后的指令和数据放到内存中适当的位置。

  * 目标机器代码。

### 编译系统的结构

* 编译的本质是一个翻译的过程，输入是高级语言程序，输出是汇编语言程序或机器语言程序。
* 人工英汉翻译的例子：
  * 第一步：分析源语言——语义分析 <- 语法分析 -< 词法分析。
  * 第二步：生成目标语言。
* 编译器的结构/阶段（在实现过程中，多个阶段可能被组合在一起）：
  * 分析部分/前端，与源语言有关：
    * 词法分析器：输入字符流，输出词法单元流
    * 语法分析器：输入词法单元流，输出语法树
    * 语义分析器：输入语法树，输出语法树
    * 中间代码生成器：输入语法树，输出中间表示形式
  * 机器无关代码优化器：输入中间表示形式，输出中间表示形式
  * 综合部分/后端，与目标语言相关：
    * 目标代码生成器：输入中间表示形式，输出目标机器语言
    * 机器相关代码优化器：输入目标机器语言，输出目标机器语言

### 词法分析概述

* 词法分析的主要任务：从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元(token)形式。token: <种别码，属性值>。
* 单词类型——种别——种别码
  * 关键字——program、if、else、then......——一词一码。
    * 给定一个程序语言，它的关键字是可以确定的，一词一个种别码，此时属性值为空。
  * 标识符——变量名、数组名、记录名、过程名......——多词一码。
    * 标识符是一个开放的集合，不能事先枚举，分别同一个种别码，通过属性值来互相区分。
  * 常量——整型、浮点型、字符型、布尔型、......——一型一码。
    * 常量是一个开放的集合，不能事先枚举，但不同类型的常量构成方式不同，每种类型的常量一种种别码，通过属性值来互相区分。
  * 运算符——算术、关系、逻辑——一词一码或一型一码。
    * 可采用一词一码（为每个运算符分配种别码）或一型一码（分为三类，每类通过属性值互相区分）。
  * 界限符——；（）={}......——一词一码。

### 语法分析概述

* 语法分析的主要任务是从词法分析器输出的 token 序列中识别出各类短语，并构造语法分析树，语法分析树描述了语法的具体结构。
* 文法是由一系列规则构成。

### 语义分析概述

* 语义分析主要任务是收集标识符的属性信息，并存放在符号表的数据结构中：
  * 种属：判断标识符是简单变量、复合变量（数组、记录、…）还是过程；
  * 类型：整型、实型、字符型、布尔型、指针型、…；
  * 存储位置、长度：计算每个变量等的相对地址；
  * 值；
  * 作用域；
  * 参数和返回信息：参数个数、参数类型、参数传递方式、返回值类型、…。
* 符号表通常带有一个“字符串表”，用来存放程序中用到的标识符和字符常数。因此 NAME 字段被分成两个部分，一部分用来存放标识符在字符串表（一种数据结构）中的起始位置，另一部分用来存放长度。
* 语义分析的另一个主要任务是语义检查，常见的错误有：
  * 变量或过程未经声明就使用；
  * 变量或过程名重复声明；
  * 运算分量类型不匹配，这时可能要进行类型转换；
  * 操作符与操作数之间的类型不匹配。
    * 数组下标不是整数；
    * 对非数组变量使用数组访问操作符；
    * 对非过程名使用过程调用操作符；
    * 过程调用的参数类型或数目不匹配；
    * 函数返回类型有误。

### 中间代码生成及编译器后端概述

* 常用的中间表示形式：
  * 三地址码是由类似于汇编语言的指令序列组成，每个指令最多又三个操作数，常用的三地址指令有：
    * 赋值指令、复制指令、条件跳转、非条件跳转、参数传递、过程调用、过程返回、数组引用、数组赋值、地址及指针操作。
  * 语法结构树/语法树。
* 三地址指令的地址可以具有如下形式之一：
  * 源程序中的名字（标识符）；常量；编译器生成的临时变量。
* 将三地址指令表示成数据结构，有以下几种情况：
  * 四元式：(op, y, z, x)，op 是操作符，x、y、z 是三个操作数；
  * 三元式；
  * 间接三元式。
* 一个三地址指令序列唯一确定了一个运算完成的顺序。
* 目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言。
* 目标代码生成的一个重要任务是为程序中使用的变量合理地分配寄存器。
* 代码优化为改进代码所进行的等价程序变换，使其运行得更快一些、占用空间更少一些，或者二者兼顾。

## 第二讲 程序设计语言及文法

### 基本概念

* 字母表 ∑ 是一个有穷符号集合，符号：字母、数字、标点符号
* 字母表上的运算：乘积、n 次幂(长度为 n 的符号串构成的集合)、正闭包、克林闭包(任意长度可以为零的符号串构成的集合)。
* 串是字母表中符号的一个有穷序列，串上的运算有：连接、幂(串 s 的 n 次幂就是将 n 个 s 串连接起来)。

### 文法的定义

* 文法的形式化定义 G = (VT, VN, P, S)：
  * VT：终结符集合，是文法所定义的语言的基本符号，有时也成为 token；
  * VN：非终结符集合，是用来表示语法成分的符号，有时也称“语法变量”；
    * VT ∪ VN = ∅
  * P：产生式集合，描述了将终结符和非终结符组成串的方法，一般形式 α→β；
  * S：文法开始符号，表示该文法中最大的语法成分。
* 文法约定：不引起歧义的前提下，可以只写产生式。
* 符号约定。
  * 下述符号是终结符：
    * 字母表中排在前面的小写字母，如 a、b、c；
    * 运算符，如 +、* 等；
    * 标点符号：如括号、逗号等；
    * 数字：0、1、…、9；
    * 粗体字符串：如 id、if 等。
  * 下述符号是非终结符
    * 字母表中排在前面的大写字母，如 A、B、C；
    * 字母 S。通常表示开始符号；
    * 小写、斜体的名字。如 expr、stmt 等；
    * 代表程序构造的大写字母。如 E(表达式)、T(项)、F(因子)。
  * 字母表中排在后面的大写字母（如 X、Y、Z）表示文法符号（即终结符或非终结符）。
  * 字母表中排在后面的小写字母（主要是 u、v、…、z）表示终结符号串（包括空串）。
  * 小写的希腊字母，如 α、β、γ，表示文法符号串（包括空串）。
  * 除非特别说明，第一个产生式的左部就是开始符号。
* 推导和规约：…，规约是推导的逆过程。
* 有了文法（语言规则），如何判定某一词串是否是该语言的句子？
  * 句子的推导（派生）——从生成语言的角度
  * 句子的归纳——从识别语言的角度
* 句型和句子：...
* 语言的形式化定义：由文法 G 的开始符号 S 推导出的所有句子构成的集合称为文法 G 生成的语言，记为 L(G)。文法解决了无穷语言的有穷表示问题。

### 文法的分类

* 文法分类体系：
  * 0 型文法：无限制文法/短语结构文法；
  * 1 型文法：上下文有关文法；
  * 2 型文法：上下文无关文法，CFG；
  * 3 型文法：正则文法（右线性文法和左线性文法）。
* 由正则文法描述的语言被称作正则语言，正则文法能描述程序设计语言的多数单词。
* 四种文法之间的关系：
  * 逐级限制；
  * 逐级包含；

### CFG 的分析树

* 分析树的根节点的标号为文法开始符号。
* 分析树是推导的图形化表示。
* （句型的）短语：给定一个句型，其分析树中的每一棵字树的边缘成为该句型的一个短语。
* 如果子树只有父子两代结点，那么这颗子树的边缘称为该句型的一个直接短语。直接短语一定是某个产生式的右部。反过来并不一定是。
* 二义性文法：如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。大多数编译器不期望遇到二义性语法，比如 if else else。

## 第三讲 词法分析

### 正则表达式

* 正则表达式是一种用来描述正则语言的更紧凑的表示方法。
* 正则表达式可以由较小的正则表达式按照特定规则递归地构建。每个正则表达式 r 定义（表示）一个语言，记为 L(r)。这个语言也是根据 r 的子表达式所表示的语言递归定义的。
* 正则表达式的定义。

### 正则定义

* 为了方便起见，我们可以给某些正则表达式命名，然后像使用字母表中的符号一样使用这些名字来构造正则表达式。
* C 语言中标识符的正则定义：
  * digit->0|1|2|…|9
  * letter_->A|B|…Z|a|b|…|z|
  * id->letter_(letter|digit)n次方

### 有穷自动机

* 这类系统具有一系列离散的输入输出信息和有穷数目的内部状态。状态概括了过去输入信息处理的状况。
* 有穷自动机由输入带、读头和有穷控制器组成。
* 最长子串匹配原则：当输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配（>= 会被翻译为大于等于）

### 有穷自动机的分类

* 确定的有穷自动机：有穷状态集，输入字母表，开始状态，接收状态。
* 一个有穷自动机 DFA，即可以用转换图来表示，又可以用转换表来表示。
* 非确定的有穷自动机 NFA 可以与 DFA 相互转换。
* 正则表达式跟有穷自动机、正则文法三者之间相互等价。

### 从正则表达式到有穷自动机

* 字母表中的每一个符号也是正则表达式。

### 从 NFA 到 DFA 的转换方法

* DFA 的每个状态都是一个由 NFA 中的状态构成的集合，即 NFA 状态集合的一个子集。

### 识别单词的 DFA

* ​

## 第四讲 语法分析_1

### 自顶向下的分析

* 从分析树的顶部（根节点）向底部（叶节点）方向构造分析树
* 可以看成是从文法开始符号 S 推导出词串 w 的过程
* 在每一步推导中，都需要做两个选择
  * 替换当前句型中的哪个非终结符
  * 用该非终结符的哪个候选式进行替换
* 在最左推导中，总是选择每个句型的最左非终结符进行替换。
* 在最右推导中，总是选择每个句型的最右非终结符进行替换，最左规约是其逆过程。
  * 在最右推导中，总是选择每个句型的最右非终结符进行替换；
  * 在自底向上的分析中，总是采用最左规约的方式，因此把最左规约成为规范规约，而最右推导相应地成为规范推导。
* 自顶向下的语法分析采用最左推导的方式：
  * 总是选择每个句型的最左非终结符进行替换；
  * 根据输入流中的下一个终结符，选择最左非终结符的一个候选式。
* 自顶向下的语法分析的通用形式：
  * 由一组过程组成，每个过程对应一个非终结符；
  * 从文法开始符号 S 对应的对此开始，其中递归调用文法中其它非终结符号对应的过程。如果 S 对应的过程体恰好扫描了整个输入串，则成功完成语法分析。
* 预测分析是递归下降分析技术的一个特例，通过在输入中向前看固定个数（通常为 1）符号来选择正确的 A- 产生式。
  * 可以对某些文法构造出向前看 k 个输入符号的预测分析器，该类文法有时也称为 LL(k) 文法类；
* 预测分析不需要回溯，是一种确定的自顶向下分析方法。

### 文法转换

* 并不是所有文法都适合自顶向下的分析。
* 当同一非终结符的多个候选式存在共同前缀的时候，就会导致回溯现象。
  * 提取左公因子法算法：通过改写产生式来推迟决定，等读入了足够多的输入，获得足够信息后再做出正确的选择。
* 含有 A->Aa 形式产生式的文法成为是直接左递归的文法；如果一个文法中有一个非终结符 A 使得对某个串 a 存在一个推导 A=>+Aa，那么这个文法就是左递归的；经过两步或两步以上推导产生的左递归称为是间接左递归的。
* 消除直接左递归算法：替换成等价的产生式，代价是引入了一些非终结符和空产生式。
* 消除间接左递归算法。

### LL(1) 文法

* S_文法，简单的确定性文法：每个产生式的右部都已终结符开始，；同一非终结符的各个候选式的右部都以终结符开始；不包含空产生式。
* 预测分析法的工作过程。
* 非终结符的后继符号集。
* 产生式的可选集，q_文法。
* 串首终结符。
* LL(1) 文法。