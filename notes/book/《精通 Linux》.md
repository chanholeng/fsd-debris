# 精通 Linux



## 概述

* Linux 操作系统主要分三层：
  * 用户进程，包括图形用户界面、服务器、命令行。进程由内核统一管理。
  * Linux 内核，包括系统调用、进程管理、内存管理、设备驱动程序。
  * 硬件，包括中央处理器、主内存、磁盘、网络端口。
* 内核和用户进程最主要的区别是：内核在内核模式中运行，用户进程在用户模式中运行。在内核模式中运行的代码可以不受限地访问中央处理器和内存，那些只有内核可以访问的空间我们成为内核空间。
* 内核和进程在主内存中运行，它们是一系列比特的大合集。
* 每一个进程拥有自己的内存区块，且内核必须确保每个进程只使用它自己的内存区块。
* 内核负责管理下面四个方面：
  * 进程：内核决定哪个进程可以使用 CPU。
  * 内存：内核管理所有的内存，为进程分配内存，管理进程间的共享内存及空闲内存。
  * 设备管理驱动程序：作为硬件系统和进程之间的接口，内核负责操控硬件设备。
  * 系统调用和支持：进程通常使用系统调用和内核进行通信。
* 进程管理涉及进程的启动、暂停、恢复和终止。一个进程让出 CPU 使用权给另一个进程称为上下文切换。内核负责上下文切换。
* 内存管理中，内核要保证以下所有条件：
  * 内核需要自己的专有内存空间
  * 每个用户进程有自己的专有内存空间
  * 一个进程不能访问另一个进程的专有内存空间
  * 用户进程之间可以共享内存
  * 用户进程的某些内存可以是只读的
  * 通过使用磁盘交换，系统可以使用比实际内存容量更多的内存空间
* 现代的 CPU 提供了 MMU，内存管理单元。MMU 使用了虚拟内存的内存访问机制。
* fork() 和 exec() 这两个系统调用对于我们了解进程如何启动很重要。
  * fork()：当进程调用 fork() 时，内核创建一个和该进程几乎一模一样的副本。
  * exec()：当进程调用 exec(program) 时，内核启动 program 来替换当前的进程。
* 除了 init 外，Linux 中的所有所有用户进程都是通过 fork() 来启动的。
* 除了传统的系统调用，内核还为用户进程提供其他很多功能，最为常见的是虚拟设备。虚拟设备对于用户进程而言是物理设备，但实际上它们很多都存在于内核中。
* 内核分配给用户进程的内存我们称之为用户空间。用户空间可以指所有用户进程占用的所有内存。Linux 中大部分的操作都发生在用户空间中。

## 基础命令和目录结构

* Unix 的 shell 有很多种，它们都是基于 Bourne shell（/bin/sh）这个贝尔实验室开发的标准 shell，在早起的 Unix 系统上运行。所有基于 Unix 的操作系统都需要 Bourne shell 才能正常工作。
* cat 命令之所以叫 cat ，是因为如果有多个文件的话，它会把这些文件的内容拼接起来显示。
* Unix 使用 I/O 流来读写数据。进程从输入流中读取数据，向输出流写出数据。输入流可以是文件、设备、终端，甚至还可以是来自其他进程的输出流。
* 内核为每个进程提供一个标准输出流供它们输出数据。
* shell 中可以保存一些临时变量，称作 shell 变量，它们是一些字符值。
* Unix 程序的很多错误与文件和进程有关。常见的错误：
  * No such file or directory：访问一个不存在的文件或目录。
  * File exists：如果新建文件的名称和现有的文件或者目录重名，就会出现这个错误。
  * Not a directory, Is a directory：这个错误出现在当你把文件当作目录或者反之把目录当作文件。
  * No space left on device：磁盘空间不足。
  * Permission denied：当你试图读或写一个没有访问权限的文件或目录时遇到的错误。
  * Operation not permitted：当你试图终止一个你无权终止的进程时遇到的错误。
  * Segmentation fault, Bus error：分段故障，总线错误。
* ps 命令列出所有正在运行的进程：
  * pid：进程 ID。
  * TTY：进程所在的终端设备。
  * STAT：进程在内存中的状态。S 表示进程正在休眠，R 表示进程正在运行。
  * TIME：进程目前为止所用 CPU 时长。
  * COMMAND：命令名，请注意进程有可能将其初始值改为其他。
* ps 命令有很多选项，你可以使用三种方式来设置选项：Unix 方式、BSD 方式和 GNU 方式。BSD 方式被认为是比较好的一种，因为它相对简单一些。下面是一些比较实用的选项的组合。
  * ps x：显示当前用户运行的所有进程。
  * ps ax：显示系统当前运行的所有进程，包括其他用户的进程。
  * ps u：显示更详细的进程信息。
  * ps w：显示命令的全名，而非仅显示一行以内的内容。
* 要终止一个进程，可以使用 kill 命令向其发送一个信号。信号是内核发送给进程的一条消息。信号的种类有很多，默认是 TERM。你可以设置选项来发送不同类型的信号。例如 STOP 信号可以让进程暂停，而不是终止；被暂停的进程仍然驻留在内存，等待被继续执行。使用 CONT 信号可以继续执行进程。CTRL -C 终止当前进程的效果和 kill -KILL 一样。
* KILL 会强行终止进程，并将其移出内存，不会给进程清理和收尾的机会，不要随便终止一个你不知道的进程。
* 符号链接是指向文件或目录的文件，相当于文件的别名。符号链接为复杂的目录提供了边界快速的访问方式。可以使用 ln -s （没有 -s 则会生成硬链接）创建符号链接，能方便我们管理、组织、共享文件。
* 压缩命令：
  * gzip 命令是 Unix 上众多标准压缩程序中的一个。GNU Zip 生成的压缩文件带有后缀名 .gz，解压缩 .gz 文件使用 gunzip file.gz 命令，压缩文件使用 gzip file 命令。gzip 命令只压缩单个文件。
  * tar 命令可以压缩和归档多个文件和目录。tar 命令生成的文件带有后缀 .tar。
  * 压缩归档文件：.tar.gz。我们可以按照从右到左的顺序来解压和打开此类文件。
  * zcat 命令等同于 gunzip -dc 命令。选项 d 代表解压缩，c 代表将运行结果输出到标准输出。
  * Unix 中另一个压缩命令式 bzip2，生成后缀名为 .bz2 的文件，执行效率比 gzip 稍慢，在压缩源代码时比较常用。tar 命令的 j 选项使用 bzip2 来压缩和解压缩。
* Linux 目录结构基础：
  * /bin：存放可执行文件，包括大部分基础的 Unix 命令。
  * /dev：设备文件。
  * /etc：存放重要的系统配置文件。例如 /etc/X11 目录中是显示卡视窗系统的配置文件。
  * /home：用户的个人目录。
  * /lib：存放供可执行程序使用的各种代码库，代码库分为静态库和共享库。
  * /proc：通过一个可浏览的目录与文件接口来存放系统相关信息，比如当前运行的进程和内核信息。
  * /sys：类似 /proc，里面是设备和系统的信息。
  * /sbin：可执行的系统文件 ，这些可执行文件用来管理系统。
  * /tmp：存放无关紧要的临时文件，所有用户对该目录都有读和写的权限，不过可能对别人的文件没有权限。很多系统会在启动时清空 /tmp 目录。
  * /usr：存放许多 Linux 系统文件，也为了让 root 文件系统占用尽可能少的空间。
  * /var：是程序存放运行时信息的地方，如系统日志、用户信息、缓存和其他信息。
* /root 目录下还有以下子目录：
  * /boot：存放内核加载文件。
  * /media：：加载可移除设备的地方，比如可移动硬盘。
  * /opt：存放第三方软件，许多系统并没有这个目录。
* /usr 目录存放那些运行在用户空间中的进程和数据，里面还有：
  * /bin。
  * /lib。
  * /include：存放 C 编译器需要使用的头文件。
  * /info：存放 GNU 帮助手册。
  * /local：管理员安装软件的地方。
  * /man：存放用户手册。
  * /share：存放 Unix 系统间的贡献文件。
* Linux 系统的内核通常在 /vmlinuz 或者 /boot/vmlinuz 中。系统启动时，引导装载程序将这个文件加载到内存并运行。引导装载程序执行完成后，系统就不再需要内核文件了。不过，系统在运行过程中会根据需要加载和卸载许多模块，我们称之为可加载内和模块，它们在 /lib/modules 目录下可以找到。
* Linux 命令可以执行的功能有：运行程序、重定向输出、文件和目录操作、查看进程、查看帮助手册以及用户空间。

## 设备管理

* 大多数设备的 I/O 接口都是以文件xi那个是由内核呈现给用户的，这些设备文件有时又叫作设备节点。
* Linux 处理设备文件的方式和 Unix 一样。设备文件存放在 /dev 目录中，可以使用 ls /dev 命令来查看。
* 设备文件的文件模式：
  * 块设备：程序从块设备中按固定的块大小读取数据。进程能通过内核访问磁盘上的任意区块。
  * 字符设备：处理流数据。你只能对字符设备读取和写入字符数据。字符设备没有固定容量，当你对字符设备进行读写时，内核对相应的设备进行读写操作。典型例子是打印机，内核在流数据送达设备和进程后不会备份和再次验证。
  * 管道设备：命名管道设备和字符设备类似，不同的是输入输出端不是内核驱动程序，而是另外一个进程。
  * 套接字设备：是跨进程通信经常用到的特殊接口，经常会存放于 /dev 目录之外。
* 相同类型的设备一般有相同的主设备号。
* 并不是所有的设备都有对应的设备文件，如网络接口。
* sys 设备路径
  * 传统的 Unix /dev 目录为用户进程与使用内核支持的设备进行引用与交互提供了便利，但过于简单。同时，内核根据其找到设备的顺序为设备文件命名，所以系统每次重新启动后，设备文件名有可能不同。
  * Linux 内核通过一个文件和目录系统提供 sysfs 界面，旨在基于硬件属性统一显示设备的相关信息。设备以 /sys/devices 为 root 路径。
  * /dev 目录中的文件是供用户进程使用设备的，而 /sys/devices 中的文件是用来查看设备信息和管理设备用的。
  * 在 /dev 目录中查看设备文件的 sysfs 路径不太方便，可以使用 udevadm 命令来查看路径和其他属性。如 ```udevadm info --query=all --name=/dev/sda```
* dd 命令和设备
  * dd 命令对于块设备和字符设备非常有用，主要功能是从输入文件和输入流读取数据然后写入输出文件和输出流，此过程中可能涉及到编码转换。
  * dd 命令复制固定大小的数据块。
  * 如何借助字符设备使用 dd 命令：```dd if=/dev/zero of=new_file bs=1024 count=1 ```。这条命令是从 /dev/zero 复制一个大小为 1024 字节的数据块到文件 new_file
  * dd 命令的格式选修沿袭了 IBM Job Control Language(JCL) 的风格，使用 = 而不是 - 符号来设定选项和参数值。
  * dd 命令一些重要选项。
* 硬盘：/dev/sd*
  * 目前 Linux 系统中的硬盘设备大部分都以 sd 为前缀来命名，这些设备代表整块硬盘。内核使用单独的设备文件名来代表硬盘上的分区。
  * sd 代表 SCSI disk。SCSI 全称小型计算机系统接口，最初是作为设备之间通信的硬件协议标准开发的。USB 存储设备就使用 SCSI 协议进行通信。
  * 我们可以使用 sysfs 系统提供的命令来查看系统中的 scsi 设备，最常用的命令之一是 lsscsi。
  * 大部分现代 Linux 系统使用通用唯一标识符 UUID 来访问设备。
* CD 和 DVD：/dev/sr*
  * Linux 系统能够将大多数光学存储设备识别为 SCSI 设备，老接口的可能被识别为 PATA 设备。
  * /dev/sr* 是只读的，它们只用于从光盘上读取数据。
* PATA 硬盘：/dev/hd*
  * 老版本 Linux 内核常用设备文件 /dev/hd* 来代表老的块设备，这是基于主从设备接口 0 和 1 的固定设置方式。STAT 设备有时候也被这样识别，表示 SATA 设备在兼容模式中运行，会造成性能损失。
* 终端设备 /dev/tty/\*、/dev/pts/\* 和 /dev/tty
  * 终端设备负责在用户进程和输入输出设备之间传送字符，通常是在终端显示屏上显示文字，可以追溯到手动打字机的时代。
  * 伪终端设备模拟终端设备的功能，由内核为程序提供 I/O 接口，而不是真实的 I/O 设备，shell 窗口就是伪终端。
  * 常见的俩个终端设备是 /dev/tty1(第一虚拟控制台) 和 /dev/pts/0(第一虚拟终端)，/dev/pts 目录中有一个专门的文件系统。
  * /dev/tty 代表当前进程正在使用的终端设备，虽然不是每个进程都连接到一个终端设备。
  * Linux 有两种显示模式：文本模式和 X Windows 系统服务器(即图形模式)。通常系统在文本模式下启动。
  * Linux 系统支持虚拟控制台来实现多个终端的显示，虚拟控制台可以在任意显示模式下有哪些。
* 串行端口：/dev/ttyS*
  * 老式的 RS-232 和串行端口是特殊的终端设备，串行端口在命令行上运用不太广。
* 并行端口：/dev/lp0 和 /dev/lp1
  * 单向并行端口设备，目前被 USB 广泛取代的一种接口类型。
* 音频设备：/dev/snd/*、/dev/dsp、/dev/audio 和其他
  * Linux 系统有两组音频设备，分别是高级 Linux 声音架构 ALSA 和开放声音系统 OSS。
  * OSS dsp 和音频设备支持一些基本操作，如可以将 WAV 文件发送给 /dev/dsp 来播放。
* 在现代 Linux 系统中，创建自己的设备文件的工作是由 devtmpfs 和 udev 来完成。
* udev：
  * 内核中的一些毫无必要的复杂功能会降低系统的稳定性。
  * 如果你可以在用户空间内创建设备文件的话，就不需要在内核空间做。
  * Linux 系统内核在检测到新设备的时候，会向用户空间进程发送消息，称为 udevd。用户空间进程会在另一段验证新设备的属性，创建设备文件，执行初始化。