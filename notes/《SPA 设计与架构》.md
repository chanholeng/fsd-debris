# SPA 设计与架构：理解单页 Web 应用

* 很多开发者对 SPA 开发技术的整体概念时模糊的
* Web 前端开发技术可谓是当今变化最为频繁的一种
* 本书讨论的 SPA 仅限于使用 MV* 框架，React 等不包含其中
* SPA 技术正出在用户体验变革的最前沿


# 第一部分：基础知识

## 单页面应用程序介绍

* 传统的 Web 应用架构、单页面 Web 应用( SPA )架构
* 对各种框架产生深远影响的三种架构模式：MVC、MVP 以及 MVVM
* SPA 概念把 Ajax 技术拓展到页面层级
* 在传统 Web 应用中，每个新视图（HTML 页面）都在服务器端构建。传统服务器端模型示例：表现层（包含控制器）、服务层、业务层、数据层。SPA 应用的设计风格中，表现层与控制器分离，表现层在客户端下，有 MV* 框架进行视图创建与管理。
* SPA 的特点：
  * 无需刷新浏览器：初始页面加载之后，所有创建和显示视图所需的内容将下载并准备就绪
  * 表现逻辑位于客户端：路由到正确视图、整合数据与 HTML 模板、管理视图生命周期等
  * 服务端事务处理指的是初始 HTML 页面，或被成为 SHELL 页面，具有传统页面的初始元基本元素


## MV* 框架

* 页面 HTML、样式 CSS、行为 JavaScript，分离
* 在 MV* 概念中，M 代表模型（数据、业务逻辑以及验证逻辑）、V 代表视图（用户所见以及交互页面）
  * MVC：模型-视图-控制器。控制器是应用程序的入口点，接受来自 UI 控件的信号。在此模式中，视图能够捕获模型变化，并在观察到模型改变时进行视图更新。
  * MVP：模型-视图-表示器。该模式的出发点是进一步解耦模型与 MVC 其他俩个组件的关系。
  * MVVM：模型-视图-视图模型。该模式的视图模型可以掌握视图与模型的变化，并保持两者同步。
  * MVW：模型-视图-无所谓是什么模型。框架有效性优于框架分类，遵循良好设计并关注分离即可。
* 传统 UI 设计模式是 MV* 的基石。
* 隐式模型和显式模型：
  * 隐式模型：Knockout、AngularJS 等。在该模型中，模型就是数据本身，而非框架规定的显示结构，其数据源可以是任意的。例如数据来源于用户所写的表单，不像创建 JavaScript 对象或者从服务器端获取 JSON 格式数据，我们需要直接从表单的 INPUT 输入字段中获取数据。 
  * 显式模型：BackboneJS 等。在该模型中，模型作为 JavaScript 对象创建。
* 绑定语法有两个特性：表达式，用来包装/限制绑定条目的特殊字符；HTML 属性。
* 双向绑定、单向绑定和单次绑定：
  * 双向绑定：在绑定连接建立后，改变任何一端的状态都会导致对端随之更新。
  * 单向绑定：源状态的改变会影响目标状态，但反之则不然。这种类型的绑定通常跟那些不需要用户输入的 HTML 元素有关。
  * 双向绑定与单向绑定：双向绑定会多一些开销。如果视图需要接受用户输入，而且数据与视图间始终需要保持同步，则应该选择双向绑定的方式。如果 UI 元素是只读的，则选择单向绑定的方式。单向绑定在模型改变时会同步更新视图，但不会监控视图端，因为元素是只读的。
  * 单次绑定：是单向绑定的一种类型，但绑定作用只会发生一次。Backbone.js 渲染模板的典型方式是单次绑定，需要更新数据时，视图被摧毁并重建。
* 模板是 HTML 片段，其作为视图如何渲染的方式。一个视图由一个或多个模板创建。
* 为什么要用 MV* 框架？关注分离、简化日常任务、提高生产率、标准化。
* 如何选择框架：是点菜方式还是一站式购物风格？许可与支持？编程风格偏好？学习曲线？bug 与修复率？文档？成熟度？社区？灵活度？概念性验证？

## JavaScript 模块化

* 模块模式创建于 2003 年，并通过 Douglas Crockford 的演讲得到普及，一些模块模式的概念：
  * 命名空间：命名空间是一种为一组相关成员提供具体作用域的方式。
  * 匿名函数表达式：函数表达式是表达式的一部分，且不以 function 关键字开头。
  * 对象字面量：其通过花括号声明一个对象，它的 Property 用键值对来表示。
  * 闭包：通常情况函数执行完毕，其中创建的任何局部变量的生命周期也就宣告结束。闭包则是另外一种情况，即使模块模式的外层函数立即执行完毕，只要模块仍在用，外层函数返回语句所引用作用于连上的任何对象或值，都无法被垃圾回收。
* 模块结构巧妙地使用一个函数作为封装其逻辑的容易，模块内部功能的访问可以通过返回语句暴露的内容来控制。容器函数分为“私有的内部变量与函数”与“返回对象字面量中的公有函数”两部分。
* 揭示模式使公有接口的使用更加清晰。思路是：将任何 API 所需代码移动到内部，将公有函数作为纯粹指向内部代码的指针，并只暴露该公有函数。
* 当模块通过 script 标签加载时，其加载顺序非常重要，模块应按现实所需顺序加载。
* 模块结构遵循以下原则：
  * 保持私有代码部分只能在模块中引用。
  * 创建公有 API，以控制模块功能的访问。
* 模块化编程的意义：
  * 避免命名冲突：“迄今为止，JavaScript 语言最糟糕的设计就是全局变量”。
  * 保护代码的完整性：我们可以通过模块模式限定变量和函数的访问权限。
  * 隐藏复杂性：将复杂逻辑放至内部并只通过公有接口暴露开发者所需功能。
  * 降低代码改变带来的冲击：如果 API 协议保持不变，因疏忽而引入无关代码的可能性将大大降低。
* 将代码重构进一个组织良好的单元，会在代码重用、维护及升级等方面带来更高效率。
* 模块模式的不足：不利于单元测试私有函数、不利于对内部对象添加拓展。
* 模块的样板结构：

```
var moduleName = (function () {
  // 私有内部变量与函数
  return {
    // 对象字面量中的公有函数，推荐使用揭示模式
  }
})()
```

* JavaScript 只有两种作用域类型：局部和全局。JavaScript  构建私有性的唯一方式就是在函数中声明局部变量和函数。
* 创建模块公有 IP 的方式有：
  * 返回对象字面量：返回的对象可以是任意类型的变量与函数，暴露的函数仅仅不过是指向模块内部函数的指针而已。
  * 让函数立即返回：这通常被称为立即调用函数表达式。
  * 闭包构造：闭包能在 IIFE 完成执行后仍维系着内部功能的生存期。
* 在大多数浏览器中，模块文件用到的 script 标签会产生阻塞，脚本加载时应用程序将暂停。因此，模块文件数越多，等待应用加载的时间就越长，而用户感受到的延迟现象也就越严重。同时大量的 HTTP 请求也将使网络不堪重负。为了缓解该问题，我们可以将模块合并到尽可能少的文件当中去，之后优化最终文件。
* 通过 script 的 defer 和 async 属性，HTML 为 JavaScript 代码的加载和执行引入了原生的非阻塞支持。
* 异步模块定义——AMD。
* 一些 RequireJS  的基础知识：
  * data-main：当在 SPA 应用中添加一个包含 RequireJS 库的 script 标签时，也需要为其添加一个 data-main 属性。data-amin 属性是加载了 RequireJS 的应用入口。通常情况下，主 JavaScript 文件包含 RequireJS 配置及 require 指令以执行初始 AMD 模块。
  * requirejs.config()：该函数创建 RequireJS 配置项，其唯一参数是一个对象字面量，该对象字面量包含了所有配置项及其值。
  * baseUrl：相对于 Web 应用根目录的路径，配置对象中的任何其他路径都相对于该路径。
  * path：映射模块名称到 Web 服务器的路径上。


# 第二部分：核心概念

## 单页面导航

* ​

