# JavaScript 标准参考教程

http://javascript.ruanyifeng.com/

http://javascript.ruanyifeng.com/nodejs/basic.html

> 难点：call、apply、bind

## 语法

* 优先采用“严格相等运算符”（`===`），而不是“相等运算符”（`==`）
* `-->`只有在行首，才会被当成单行注释，否则就是一个运算符。
* 基本数据类型：
  * 数值（number）：整数和小数（比如1和3.14）
  * 字符串（string）：字符组成的文本（比如”Hello World”）
  * 布尔值（boolean）：`true`（真）和`false`（假）两个特定值
  * `undefined`：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值
  * `null`：表示无值，即此处的值就是“无”的状态。
  * 对象（object）：各种值组成的集合
* JavaScript的特殊值：NaN、Infinity
* 对象又可以分成三个子类型：狭义的对象（object）、数组（array）、函数（function）
* JavaScript的所有数据，都可以视为广义的对象。不仅数组和函数属于对象，就连原始类型的数据（数值、字符串、布尔值）也可以用对象方式调用。
* 另外，`null`的类型也是`object`，这是由于历史原因造成的。1995年JavaScript语言的第一版，所有值都设计成32位，其中最低的3位用来表述数据类型，`object`对应的值是`000`。当时，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），完全没考虑`null`，只把它当作`object`的一种特殊值，32位全部为0。这是`typeof null`返回`object`的根本原因。
* ```null``` 和 ```undefined``` 区别：1995年 JavaScript 诞生时，最初像Java一样，只设置了`null`作为表示”无”的值。根据C语言的传统，`null`被设计成可以自动转为`0`。但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。首先，`null`像在Java里一样，被当成一个对象。但是，JavaScript的值分成原始类型和合成类型两大类，Brendan Eich觉得表示”无”的值最好不是对象。其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果`null`自动转为0，很不容易发现错误。因此，Brendan Eich又设计了一个`undefined`。他是这样区分的：`null`是一个表示”无”的对象，转为数值时为`0`；`undefined`是一个表示”无”的原始值，转为数值时为`NaN`。
* JavaScript有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。
* 如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为`false`，其他值都视为`true`：`undefined`、`null`、`false`、`0`、`NaN`、`""`或`''`（空字符串）
* JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。
* 根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的：第1位：符号位，`0`表示正数，`1`表示负数；第2位到第12位：指数部分；第13位到第64位：小数部分（即有效数字）。EEE 754 规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是`1.xx...xx`的形式，其中`xx..xx`的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。```(-1)^符号位 * 1.xx...xx * 2^指数位``` 公式是一个数在 JavaScript 内部实际的表示形式。所以，```-(2^53-1)到2^53-1``` 范围以外的数值，都无法保持精度。
* 根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为```2^1024到2^-1023```（开区间），超出这个范围的数无法表示。
* 1995年 JavaScript 诞生时，最初像Java一样，只设置了`null`作为表示”无”的值。根据C语言的传统，`null`被设计成可以自动转为`0`。
* 反斜杠还有三种特殊用法：
  * `\HHH`：反斜杠后面紧跟三个八进制数（`000`到`377`），代表一个字符。`HHH`对应该字符的Unicode码点，比如`\251`表示版权符号。显然，这种方法只能输出256种字符
  * （2）`\xHH`： `\x`后面紧跟两个十六进制数（`00`到`FF`），代表一个字符。`HH`对应该字符的Unicode码点，比如`\xA9`表示版权符号。这种方法也只能输出256种字符。
  * （3）`\uXXXX`： `\u`后面紧跟四个十六进制数（`0000`到`FFFF`），代表一个字符。`HHHH`对应该字符的Unicode码点，比如`\u00A9`表示版权符号。
* JavaScript使用Unicode字符集。也就是说，在JavaScript引擎内部，所有字符都用Unicode表示。每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。
* Base64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是为了不出现特殊字符，简化程序的处理。JavaScript原生提供两个Base64相关方法。
  - btoa()：字符串或二进制值转为Base64编码
  - atob()：Base64编码转为原来的编码
* 遍历 JS 对象的属性的方法：```Object.keys()```或```for … in …```，后者可以使用hasOwnProperty只遍历对象本身的属性。
* JavaScript语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。JavaScript使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有4294967295个（232- 1）个，也就是说`length`属性的最大值就是4294967295。
* 如果一个对象的所有键名都是正整数或零，并且有`length`属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。典型的“类似数组的对象”是函数的`arguments`对象，以及大多数 DOM 元素集，还有字符串。
* ```delete``` 命令删除一个数组成员，会形成空位，并且不会影响```length```属性。数组的空位和```undefined```是不一样的：使用数组的`forEach`方法、`for...in`结构、以及`Object.keys`方法进行遍历时空位都会跳过，如果某个位置是`undefined`，遍历的时候就不会被跳过。
* 匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。采用函数表达式声明函数时，`function`命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。
* 根据ECMAScript的规范，不能在条件语句中声明函数，最常见的情况就是if和try语句。
* 正常模式下，`arguments`对象可以在运行时修改。严格模式下，`arguments`对象是一个只读对象，修改它是无效的，但不会报错。需要注意的是，虽然`arguments`很像数组，但它是一个对象。数组专有的方法（比如`slice`和`forEach`），不能在`arguments`对象上直接使用。但是，可以通过`apply`方法，把`arguments`作为参数传进去，这样就可以让`arguments`使用数组方法了。要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。两种常用的转换方法：slice方法和逐一填入新数组。
* 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。闭包的另一个用处，是封装对象的私有属性和私有方法。外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。
* 立即调用的函数表达式（IIFE）：通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。
* 加法运算符（`+`）是最常见的运算符之一，但是使用规则却相对复杂。因为在JavaScript语言里面，这个运算符可以完成两种运算，既可以处理算术的加法，也可以用作字符串连接，它们都写成`+`。这种由于参数不同，而改变自身行为的现象，叫做“重载”（overload）。加法运算符以外的其他算术运算符（比如减法、除法和乘法），都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。
* 非字符串的比较：（1）原始类型的值：两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较。（2）对象：如果运算子是对象，会转为原始类型的值，再进行比较。对象转换成原始类型的值，算法是先调用`valueOf`方法；如果返回的还是对象，再接着调用`toString`方法。如果两个变量引用同一个对象，则它们相等。`undefined`和`null`与自身严格相等。```NaN``` 与自身不相等。
* 且运算符的运算规则是：如果第一个运算子的布尔值为`true`，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为`false`，则直接返回第一个运算子的值，且不再对第二个运算子求值。
* `void`运算符的作用是执行一个表达式，然后不返回任何值，或者说返回`undefined`。这个运算符主要是用于书签工具（bookmarklet），以及用于在超级链接中插入代码，目的是返回`undefined`可以防止网页跳转。
* 根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（`<=`)、严格相等（`===`）、或（`||`）、三元（`?:`）、等号（`=`）。因此上面的表达式，实际的运算顺序如下。
* 强制转换主要指使用`Number`、`String`和`Boolean`三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。
* `Number`函数将字符串转为数值，要比`parseInt`函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`。另外，`Number`函数会自动过滤一个字符串前导和后缀的空格。简单的规则是，`Number`方法的参数是对象时，将返回`NaN`，除非是包含单个数值的数组。
* JavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript原生提供一个`Error`构造函数，所有抛出的错误都是这个构造函数的实例。根据语言标准，`Error`对象的实例必须有`message`属性，表示出错时的提示信息，其他属性则没有提及。大多数JavaScript引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。
* Error对象是最一般的错误类型，在它的基础上，JavaScript还定义了其他6种错误，也就是说，存在Error的6个派生对象：`SyntaxError`是解析代码时发生的语法错误；`ReferenceError`是引用一个不存在的变量时发生的错误；`RangeError`是当一个值超出有效范围时发生的错误；`TypeError`是变量或参数不是预期类型时发生的错误；`URIError`是URI相关函数的参数不正确时抛出的错误；`eval`函数没有被正确执行时，会抛出`EvalError`错误，该错误类型已经不再在ES5中出现了。
* URI相关函数主要有`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。
* 除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。可以通过自定义一个`assert`函数，规范化`throw`抛出的信息。`console`对象的`assert`方法，与上面函数的工作机制一模一样，所以可以直接使用。
* 为了对错误进行处理，需要使用`try...catch`结构。`try`代码块一抛出错误（上例用的是`throw`语句），JavaScript引擎就立即把代码的执行，转到`catch`代码块。`try...catch`结构是JavaScript语言受到Java语言影响的一个明显的例子。这种结构多多少少是对结构化编程原则一种破坏，处理不当就会变成类似`goto`语句的效果，应该谨慎使用。
* 编程风格
  * 建议使用`Object.create()`命令，替代`new`命令。如果不得不使用`new`，为了防止出错，最好在视觉上把构造函数与其他函数区分开来。比如，构造函数的函数名，采用首字母大写（InitialCap），其他函数名一律首字母小写。
  * 建议避免使用`switch...case`结构，用对象结构代替。
  * 建议自增（`++`）和自减（`--`）运算符尽量使用`+=`和`-=`代替。

## 标准库

### Object 对象

* 所有构造函数都有一个prototype属性，指向一个原型对象。凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享。
* Object 本身当做工具方法使用时，可以将任意值转为对象，这个方法常用于保证某个值一定是对象。
  * 如果参数是原始类型的值，Object 方法返回对应的包装对象的实例。
  * 如果参数是一个对象，它总是返回原对象。
* 所谓“静态方法”，是指部署在 Object 对象自身的方法。
  * Object.keys()，Object.getOwnPropertyNames 方法很相似，一般用来遍历对象的属性。它们的参数都是一个对象，都返回一个数组，该数组的成员都是对象自身的（而不是继承的）所有属性名。它们的区别在于，Object.keys 方法只返回可枚举的属性。Object.getOwnPropertyNames 方法还返回不可枚举的属性名。一般情况下，几乎总是使用 Object.keys 方法，遍历数组的属性。
  * `Object.getOwnPropertyDescriptor()`：获取某个属性的`attributes`对象。
  * `Object.defineProperty()`：通过`attributes`对象，定义某个属性。
  * `Object.defineProperties()`：通过`attributes`对象，定义多个属性。
  * `Object.getOwnPropertyNames()`：返回直接定义在某个对象上面的全部属性的名称。
  * `Object.preventExtensions()`：防止对象扩展。
  * `Object.isExtensible()`：判断对象是否可扩展。
  * `Object.seal()`：禁止对象配置。
  * `Object.isSealed()`：判断一个对象是否可配置。
  * `Object.freeze()`：冻结一个对象。
  * `Object.isFrozen()`：判断一个对象是否被冻结。
  * `Object.create()`：该方法可以指定原型对象和属性，返回一个新的对象。
  * `Object.getPrototypeOf()`：获取对象的`Prototype`对象。
* Object 对象的实例方法主要由六个：除了`Object`对象本身的方法，还有不少方法是部署在`Object.prototype`对象上的，所有`Object`的实例对象都继承了这些方法。
  * `valueOf()`：返回当前对象对应的值。主要用途是，JavaScript 自动类型转换时会默认调用这个方法。
  * `toString()`：返回当前对象对应的字符串形式，默认情况下返回类型字符串。通过自定义`toString`方法，可以让对象在自动类型转换时，得到想要的字符串形式。数组、字符串、函数、Date对象都分别部署了自己版本的`toString`方法，覆盖了`Object.prototype.toString`方法。实例对象可能会自定义`toString`方法，覆盖掉`Object.prototype.toString`方法。通过函数的`call`方法，可以在任意值上调用`Object.prototype.toString`方法，帮助我们判断这个值的类型。
  * `toLocaleString()`：返回当前对象对应的本地字符串形式。
  * `hasOwnProperty()`：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。
  * `isPrototypeOf()`：判断当前对象是否为另一个对象的原型。
  * `propertyIsEnumerable()`：判断某个属性是否可枚举。

### Array 对象

* `Array`是 JavaScript 的内置对象，同时也是一个构造函数，可以用它生成新的数组。
* Array 作为构造函数有一个很大的问题，就是不同的参数，会导致它的行为不一致，不推荐使用。
  * 无参数时，返回空数组。
  * 单个正整数参数，表示返回的新数组的长度，值均为 ```undefined```。此时取不到键名。
  * 单个非正整数的数值作为参数，会报错。
  * 单个非正整数参数（比如字符串、布尔值、对象等），则该参数是返回的新数组的成员。
  * 多参数时，所有参数都是返回的新数组的成员。
* `Array.isArray` 方法用来判断一个值是否为数组，可以弥补 `typeof` 运算符的不足。
* Array 的实例方法：
  * `valueOf`方法返回数组本身。
  * `toString`方法返回数组的字符串形式。
  * `push`方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。如果需要合并两个数组，可以这样写：`Array.prototype.push.apply(a, b)`。
  * `push`方法还可以用于向对象添加元素，添加后的对象变成类似数组的对象，即新加入元素的键对应数组的索引，并且对象有一个`length`属性。
  * `pop`方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。
  * `join`方法以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。如果数组成员是`undefined`或`null`或空位，会被转成空字符串。
  * `concat`方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。如果不提供参数，`concat`方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是如果数组成员包括复合类型的值（比如对象），则新数组拷贝的是该值的引用。
  * `shift`方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。`shift`方法可以遍历并清空一个数组。
  * `unshift`方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。`unshift`方法可以在数组头部添加多个元素。
  * `reverse`方法用于颠倒数组中元素的顺序，返回改变后的数组。注意，该方法将改变原数组。
  * `slice`方法用于提取原数组的一部分，返回一个新数组，原数组不变。`slice`方法的一个重要应用，是将类似数组的对象转为真正的数组：`Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })`
  * `splice`方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。
  * `sort`方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。`sort`方法不是按照大小排序，而是按照对应字符串的字典顺序排序。如果想让`sort`方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。
  * `map`方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。`map`方法还可以接受第二个参数，表示回调函数执行时`this`所指向的对象。如果数组有空位，`map`方法的回调函数在这个位置不会执行，会跳过数组的空位。
  * `forEach`方法与`map`方法很相似，也是遍历数组的所有成员，执行某种操作，但是`forEach`方法一般不返回值，只用来操作数据。如果需要有返回值，一般使用`map`方法。注意，`forEach`方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用`for`循环。
  * `filter`方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为`true`的成员组成一个新数组返回。该方法不会改变原数组。
  * `some`方法是只要有一个数组成员的返回值是`true`，则整个`some`方法的返回值就是`true`，否则`false`。`every`方法则是所有数组成员的返回值都是`true`，才返回`true`，否则`false`。注意，对于空数组，`some`方法返回`false`，`every`方法返回`true`，回调函数都不会执行。`some`和`every`方法还可以接受第二个参数，用来绑定函数中的`this`关键字。
  * `reduce`方法和`reduceRight`方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，`reduce`是从左到右处理（从第一个成员到最后一个成员），`reduceRight`则是从右到左（从最后一个成员到第一个成员），其他完全一样。
  * `indexOf`方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回`-1`。`lastIndexOf`方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回`-1`。注意，如果数组中包含`NaN`，这两个方法不适用，即无法确定数组成员是否包含`NaN`。

### 包装对象

* 所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的`Number`、`String`、`Boolean`三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。
* 包装对象实例可以使用Object对象提供的原生方法，主要是`valueOf`方法和`toString`方法。
  * `valueOf`方法返回包装对象实例对应的原始类型的值。
  * `toString`方法返回实例对应的字符串形式。
* 原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript引擎会自动将原始类型的值转为包装对象，在使用后立刻销毁。
* 这种原始类型值可以直接调用的方法还有很多（详见后文对各包装对象的介绍），除了前面介绍过的`valueOf`和`toString`方法，还包括三个包装对象各自定义在原型上的方法。
* `Boolean`对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象的实例。`Boolean`对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时`Boolean`就是一个单纯的工具方法。`Boolean`对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时`Boolean`就是一个单纯的工具方法。

### Number 对象

* `Number`对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。作为构造函数时，它用于生成值为数值的对象。作为工具函数时，它可以将任何类型的值转为数值。
* Number 对象的属性：
  * `Number.POSITIVE_INFINITY`：正的无限，指向`Infinity`。
  * `Number.NEGATIVE_INFINITY`：负的无限，指向`-Infinity`。
  * `Number.NaN`：表示非数值，指向`NaN`。
  * `Number.MAX_VALUE`：表示最大的正数，相应的，最小的负数为`-Number.MAX_VALUE`。
  * `Number.MIN_VALUE`：表示最小的正数（即最接近0的正数，在64位浮点数体系中为`5e-324`），相应的，最接近0的负数为`-Number.MIN_VALUE`。
  * `Number.MAX_SAFE_INTEGER`：表示能够精确表示的最大整数，即`9007199254740991`。
  * `Number.MIN_SAFE_INTEGER`：表示能够精确表示的最小整数，即`-9007199254740991`。
* Number 对象实例的方法：
  * `toString`方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。
  * `toFixed`方法用于将一个数转为指定位数的小数，返回这个小数对应的字符串。
  * `toExponential`方法用于将一个数转为科学计数法形式。
  * `toPrecision`方法用于将一个数转为指定位数的有效数字。
* 与其他对象一样，`Number.prototype`对象上面可以自定义方法，被`Number`的实例继承。

### String 对象

* `String`对象是JavaScript原生提供的三个包装对象之一，用来生成字符串的包装对象。
* 实际上，字符串的包装对象是一个类似数组的对象（即很像数组，但是实质上不是数组）。
* 除了用作构造函数，`String`对象还可以当作工具方法使用，将任意类型的值转为字符串。
* String对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是`fromCharCode()`。该方法的参数是一系列Unicode码点，返回对应的字符串。
* 实例对象的属性和方法：
  * `length`属性返回字符串的长度。
  * `charAt`方法返回指定位置的字符，参数是从`0`开始编号的位置。这个方法完全可以用数组下标替代。如果参数为负数，或大于等于字符串的长度，`charAt`返回空字符串。
  * `charCodeAt`方法返回给定位置字符的Unicode码点（十进制表示），相当于`String.fromCharCode()`的逆操作。
  * `concat`方法用于连接两个字符串，返回一个新字符串，不改变原字符串。该方法可以接受多个参数。如果参数不是字符串，`concat`方法会将其先转为字符串，然后再连接。
  * `slice`方法用于从原字符串取出子字符串并返回，不改变原字符串。
  * `substring`方法用于从原字符串取出子字符串并返回，不改变原字符串。它与`slice`作用相同，但有一些奇怪的规则，因此不建议使用这个方法，优先使用`slice`。
  * `substr`方法用于从原字符串取出子字符串并返回，不改变原字符串。
  * ```indexOf()```、```lastIndexOf()```两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回`-1`，就表示不匹配。两者的区别在于，`indexOf`从字符串头部开始匹配，`lastIndexOf`从尾部开始匹配。
  * `trim`方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（`\t`、`\v`）、换行符（`\n`）和回车符（`\r`）。
  * `toLowerCase`方法用于将一个字符串全部转为小写，`toUpperCase`则是全部转为大写。它们都返回一个新字符串，不改变原字符串。
  * `localeCompare`方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。
  * `match`方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回`null`。返回数组还有`index`属性和`input`属性，分别表示匹配字符串开始的位置和原始字符串。
  * `search`方法的用法等同于`match`，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回`-1`。
  * `replace`方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有`g`修饰符的正则表达式）。
  * `split`方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。`split`方法还可以接受第二个参数，限定返回数组的最大成员数。

### Math 对象

`Math`是JavaScript的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在`Math`对象上调用。

* `Math`对象提供以下一些只读的数学常数。
  - `Math.E`：常数e。
  - `Math.LN2`：2的自然对数。
  - `Math.LN10`：10的自然对数。
  - `Math.LOG2E`：以2为底的e的对数。
  - `Math.LOG10E`：以10为底的e的对数。
  - `Math.PI`：常数Pi。
  - `Math.SQRT1_2`：0.5的平方根。
  - `Math.SQRT2`：2的平方根。
* `Math`对象提供以下一些数学方法。
  - `Math.abs()`：返回参数值的绝对值。
  - `Math.ceil()`：接受一个参数，返回大于该参数的最小整数。
  - `Math.floor()`：接受一个参数，返回小于该参数的最大整数。
  - `Math.max()`：返回其中最大的参数。
  - `Math.min()`：返回最小的参数。
  - `Math.pow()`：返回以第一个参数为底数、第二个参数为幂的指数值。
  - `Math.sqrt()`：返回参数值的平方根。如果参数是一个负值，则返回NaN。
  - `Math.log()`：返回以e为底的自然对数值。
  - `Math.exp()`：返回常数e的参数次方。
  - `Math.round()`：用于四舍五入。
  - `Math.random()`：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。
* `Math`对象还提供一系列三角函数方法。
  - `Math.sin()`：返回参数的正弦
  - `Math.cos()`：返回参数的余弦
  - `Math.tan()`：返回参数的正切
  - `Math.asin()`：返回参数的反正弦（弧度值）
  - `Math.acos()`：返回参数的反余弦（弧度值）
  - `Math.atan()`：返回参数的反正切（弧度值）

### Date 对象

* `Date`对象是JavaScript提供的日期和时间的操作接口。它可以表示的时间范围是，1970年1月1日00:00:00前后的各1亿天（单位为毫秒）。
* `Date`对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。注意，即使带有参数，`Date`作为普通函数使用时，返回的还是当前时间。
* `Date`还可以当作构造函数使用。对它使用`new`命令，会返回一个`Date`对象的实例。如果不加参数，生成的就是代表当前时间的对象。
  * `new Date(milliseconds)`：`Date`对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数。这意味着如果将Unix时间戳（单位为秒）作为参数，必须将Unix时间戳乘以1000。
  * `new Date(datestring)`：Date对象还接受一个日期字符串作为参数，返回所对应的时间。日期字符串的完整格式是“month day, year hours:minutes:seconds”，比如“December 25, 1995 13:30:00”。如果省略了小时、分钟或秒数，这些值会被设为0。
  * 事实上，所有可以被`Date.parse()`方法解析的日期字符串，都可以当作`Date`对象的参数。
  * 注意，在ES5之中，如果日期采用连词线（`-`）格式分隔，且具有前导0，JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的。
  * 总之，对于`YYYY-MM-DD`形式的字符串，JavaScript引擎可能会将其当作ISO格式来解析，采用格林尼治时区作为计时标准；而对于其他格式的日期字符串，一律视为非ISO格式，采用本地时区作为计时标准。
  * `new Date(year, month [, day, hours, minutes, seconds, ms])`：Date对象还可以接受多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒。如果采用这种格式，最少需要提供两个参数（年和月），其他参数都是可选的，默认等于0。因为如果只使用“年”这一个参数，Date对象会将其解释为毫秒数。年份如果是0到99，会自动加上1900。比如，0表示1900年，1表示1901年；如果为负数，则表示公元前。
  * 两个日期对象进行减法运算，返回的就是它们间隔的毫秒数；进行加法运算，返回的就是连接后的两个字符串。
* Date 对象的静态方法：
  * `Date.now`方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000）。
  * `Date.parse`方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数。
  * `Date.UTC`方法可以返回UTC时间（世界标准时间）。该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数。
* `Date`的实例对象，有几十个自己的方法，分为以下三类。
  - `to`类：从`Date`对象返回一个字符串，表示指定的时间。
    * `toString`方法返回一个完整的日期字符串。
    * `toUTCString`方法返回对应的UTC时间，也就是比北京时间晚8个小时。
    * `toISOString`方法返回对应时间的ISO8601写法。
    * `toJSON`方法返回一个符合JSON格式的ISO格式的日期字符串，与`toISOString`方法的返回结果完全相同。
    * `toDateString`方法返回日期字符串。
    * `toTimeString`方法返回时间字符串。
    * `toLocaleDateString`方法返回一个字符串，代表日期的当地写法。
    * `toLocaleTimeString`方法返回一个字符串，代表时间的当地写法。
  - `get`类：获取`Date`对象的日期和时间，返回的都是整数，不同方法返回值的范围不一样。
    * `getTime()`：返回距离1970年1月1日00:00:00的毫秒数，等同于`valueOf`方法。
    * `getDate()`：返回实例对象对应每个月的几号（从1开始）。
    * `getDay()`：返回星期几，星期日为0，星期一为1，以此类推。
    * `getYear()`：返回距离1900的年数。
    * `getFullYear()`：返回四位的年份。
    * `getMonth()`：返回月份（0表示1月，11表示12月）。
    * `getHours()`：返回小时（0-23）。
    * `getMilliseconds()`：返回毫秒（0-999）。
    * `getMinutes()`：返回分钟（0-59）。
    * `getSeconds()`：返回秒（0-59）。
    * `getTimezoneOffset()`：返回当前时间与UTC的时区差异，以分钟表示，返回结果考虑到了夏令时因素。
  - `set`类：设置`Date`对象的日期和时间。
    * `setDate(date)`：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。
    * `setYear(year)`: 设置距离1900年的年数。
    * `setFullYear(year [, month, date])`：设置四位年份。
    * `setHours(hour [, min, sec, ms])`：设置小时（0-23）。
    * `setMilliseconds()`：设置毫秒（0-999）。
    * `setMinutes(min [, sec, ms])`：设置分钟（0-59）。
    * `setMonth(month [, date])`：设置月份（0-11）。
    * `setSeconds(sec [, ms])`：设置秒（0-59）。
    * `setTime(milliseconds)`：设置毫秒时间戳。
  - `valueOf`方法返回实例对象距离1970年1月1日00:00:00 UTC对应的毫秒数，该方法等同于`getTime`方法。

## Dom 模型

